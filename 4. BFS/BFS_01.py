"""
# 게임 맵 최단거리 LV_2

[1] 문제 설명
목표
- 시작점(0,0)에서 도착점(n-1, m-1)까지 벽(0)을 피해서 가장 짧은 거리로 이동한 칸 수를 구해야 한다.
규칙
- 상하좌우로만 이동 가능
- 벽(0)은 지나갈 수 없음
- 시작점과 도착점은 항상 1 (지날 수 있음)
입력 값
- 2차원 배열 maps (1은 통로, 0은 벽)
출력 값
- 시작점에서 도착점까지의 최소 거리 (int)
예외 상황:
- 도달 불가능할 경우 -1을 반환해야 함

[2] 자료구조
Queue (리스트 활용): BFS 구현을 위해 사용. 순차적으로 탐색하며 거리 값을 누적하기 적합.
2차원 리스트 visited: 중복 방문을 막고, 무한 루프 방지. 이미 방문한 위치는 다시 큐에 넣지 않음.
Integer (거리): 이동한 거리 누적을 위해 사용. 큐에 함께 저장됨.
List / Tuple (좌표): 위치 정보 (x, y)를 저장할 때 사용. 리스트에서 튜플로 큐 구현.

[3] 알고리즘
BFS: 선택 알고리즘 (너비 우선 탐색)
- 이유: 최단거리이기 때문에 BFS가 적합

[4] 흐름 설계
1. myString의 각 문자를 순회하며 A는 B로, B는 A로 치환
2. 치환된 문자열에 pat이 포함되어 있는지 in 연산으로 확인
3. 포함 시 1, 포함되지 않으면 0 반환
"""

def solution(maps):
    # [1] 맵의 크기를 구함 (행: n, 열: m)
    n = len(maps)
    m = len(maps[0])

    # [2] 방문 여부를 기록할 visited 배열 초기화 (False로 시작)
    visited = [[False] * m for _ in range(n)]

    # [3] BFS를 위한 큐 준비 → (x좌표, y좌표, 현재까지의 거리)
    queue = [(0, 0, 1)]

    # [4] 시작점 방문 처리
    visited[0][0] = True

    # [5] 상, 하, 좌, 우 방향 이동을 위한 델타 배열 설정
    dx = [-1, 1, 0, 0]  # x 이동: 위, 아래
    dy = [0, 0, -1, 1]  # y 이동: 왼쪽, 오른쪽

    # [6] 큐가 빌 때까지 반복 (BFS 탐색)
    while queue:
        # [6-1] 큐에서 현재 위치 꺼내기
        x, y, dist = queue[0]
        queue = queue[1:]

        # [6-2] 도착지에 도달한 경우 → 현재까지의 거리 반환
        if x == n - 1 and y == m - 1:
            return dist

        # [6-3] 상하좌우로 이동 시도
        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]

            # [6-4] 맵을 벗어나지 않는 위치인지 확인
            if 0 <= nx < n and 0 <= ny < m:
                # [6-5] 해당 위치가 통로(1)이고 아직 방문하지 않았다면
                if maps[nx][ny] == 1 and not visited[nx][ny]:
                    visited[nx][ny] = True      # 방문 처리
                    queue.append((nx, ny, dist + 1))  # 다음 위치와 거리 기록

    # [7] 도달 불가능할 경우 -1 반환
    return -1