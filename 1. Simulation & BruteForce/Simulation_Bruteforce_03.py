"""
# 정수를 나선형으로 배치하기 LV_0

[1] 문제 설명

    (1) 목표:
    - 1부터 n²까지의 정수를 n x n 2차원 배열에 시계 방향 나선형으로 채워 반환한다.
    (2) 규칙:
    - 이동 순서: 오른쪽 → 아래 → 왼쪽 → 위 (반복)
    - 다음 칸이 범위를 벗어나거나 이미 값이 채워졌을 경우 → 방향 전환
    (3) 입력값:
    - n (int): 배열의 크기 (1 ≤ n ≤ 30)
    (4) 출력값:
    - 나선형으로 숫자가 채워진 n x n 2차원 리스트

[2] 자료구조

    (1) 2차원 리스트 (배열)

[3] 알고리즘

    (1) Simulation:
    - 숫자를 나선형으로 돌면서 하나씩 채우는 규칙
    (2) Brute Force:
    - 모든 칸을 1부터 n²까지 직접 순회하면서 값을 채움

[4] 흐름 설계

    (1) n x n 크기의 2차원 배열을 0으로 초기화
    (2) 방향 벡터(dx, dy)를 정의하여 시계 방향 순서대로 이동 제어
    (3) 초기 위치 (x, y) = (0, 0), 시작 숫자 = 1
    (4) 1부터 n²까지의 수를 배열에 채움
        - 현재 위치에 값 저장
        - 다음 위치가 범위를 벗어나거나 이미 채워졌다면 방향 전환
        - 위치 갱신
    (5) 최종 배열 반환
"""

def solution(n):
    # [1] n x n 크기의 2차원 배열을 0으로 초기화
    answer = [[0] * n for _ in range(n)]

    # [2] 시계방향 이동을 위한 방향 벡터 정의 (오른쪽 → 아래 → 왼쪽 → 위)
    dx = [0, 1, 0, -1]  # 행 이동 (x축)
    dy = [1, 0, -1, 0]  # 열 이동 (y축)

    # [3] 시작 위치: 좌측 상단 (0, 0)
    x, y = 0, 0
    direction = 0  # 현재 방향 인덱스 (0: 오른쪽, 1: 아래, 2: 왼쪽, 3: 위)

    # [4] 1부터 n^2까지 반복하면서 나선형으로 숫자 채우기
    for i in range(1, n * n + 1):
        answer[x][y] = i  # 현재 위치에 숫자 채우기

        # 다음 위치 계산
        nx = x + dx[direction]
        ny = y + dy[direction]

        # 범위 벗어나거나 이미 채워진 경우 → 방향 전환
        if nx < 0 or nx >= n or ny < 0 or ny >= n or answer[nx][ny] != 0:
            direction = (direction + 1) % 4  # 방향 인덱스 순환 (0~3)
            nx = x + dx[direction]
            ny = y + dy[direction]

        # 이동
        x, y = nx, ny

    # [5] 나선형으로 채워진 배열 반환
    return answer

# 예시 출력 (n=4일 때)
print(solution(4))
