"""
# 수열과 구간 쿼리
[1] 문제 설명
- (1) 목표
2차원 정수 배열 queries 규칙에 따라 처리 arr을 변경 한후에 정수 배열  arr 을 출력 해야함
- (2) 룰
arr [ 1, 2, 3 ]
queries [ [0,3] , [1,2] , [2,0] ]
queries에 따라서 arr의 값을 변경 해야 한다.
- queries 2차원 배열 안에 있는 값이 arr의 index를 넘어서는 경우는 ?
- i < j  / j < arr_len
- (3) 입력 값
arr / queries
- (4) 출력 값
- 변경된 arr
- (5) 예외 상황

[2] 자료구조 /알고리즘 선택
(1) Hash	빠르게 찾아야 해?	❌	빠른 탐색, 검색이 필요 없음 (값 변경만 수행)
(2) Stack / Queue	순서대로 처리해야 해?	🔶 일부 해당	쿼리를 "순서대로" 처리하긴 하지만, 스택/큐 자료구조 자체는 쓰지 않음
(3) Heap	최댓값/최솟값을 빠르게 꺼내야 해?	❌	우선순위가 없고, 최소/최대 탐색 없음
(4) Sorting	정렬이 필요한가?	❌	정렬 과정 없음. 단순 인덱스 교환만 수행
(5) Brute Force	모든 경우를 다 봐야 하는가?	🔶 유사	주어진 모든 쿼리를 순차 처리 (완전탐색에 가까운 루프 처리)
(6) Greedy	매번 최선의 선택?	❌	최적 선택의 누적이 아닌 단순한 스왑
(7) DP	이전 결과 저장해서 재사용?	❌	결과 저장이나 재활용 구조 없음
(8) Graph / DFS-BFS	연결된 요소들을 어떻게 탐색?	❌	이 문제엔 그래프 구조 없음, 노드/간선/연결 관계 없음
(9) Binary Search	정렬된 리스트에서 빠르게 찾아야 하나?	❌	이진 탐색 불필요. 정렬되어 있지 않아도 됨

[3] 흐름 설계
- 입력 자료의 성격은 ? -  List
- 출력 그대로 list
- 어떤 처리를 반복해야 하는가 ? 반복문 /인덱스 접근
- 순서를 지켜야 하는가 ? -> 순차적 처리가 필요 하다.
"""

def solution(arr, queries):
    answer = arr.copy()
    for i, j in queries:
        # 스왑(Swap) 기능
        answer[i], answer[j] = answer[j], answer[i]
    return answer