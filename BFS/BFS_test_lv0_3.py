"""
[1] ë¬¸ì œ ì´í•´
- (1) ì„ ë¶„ 3ê°œê°€ ë†“ì—¬ì ¸ ìˆê³  ê²¹ì³ìˆëŠ” ê¸¸ì´ì˜ í•©ì„ ë¦¬í„´í•œë‹¤.
- (2) input->2ì°¨ì› ë°°ì—´ lines ( 3ê°œì˜ ì„ ì˜ ì •ë³´)
- (3) output-> int answer
[2] ìë£Œêµ¬ì¡° / ì•Œê³ ë¦¬ì¦˜
- (1) Hash (dict)	âœ… ê°€ëŠ¥	ê° ì¢Œí‘œì— ì„ ë¶„ì´ ì–¼ë§ˆë‚˜ ê²¹ì³¤ëŠ”ì§€ë¥¼ dict ë˜ëŠ” ë°°ì—´ë¡œ ì„¸ë©´ ë¹ ë¦„
- (2) Stack / Queue	âŒ ë¶ˆí•„ìš”	ì„ ì…ì„ ì¶œ, í›„ì…ì„ ì¶œ í•„ìš” ì—†ìŒ
- (3) Heap	âŒ ë¶ˆí•„ìš”	ìš°ì„ ìˆœìœ„ ê°œë… ì—†ìŒ
- (4) Sorting	âŒ í•„ìš” ì—†ìŒ	ë‹¨ìˆœ ì¢Œí‘œ ì²´í¬ë¡œ í•´ê²° ê°€ëŠ¥
- (5) Brute Force Search	âœ… ì‚¬ìš©ë¨	ì¢Œí‘œ í•œ ì¹¸ì”© ëª¨ë‘ í™•ì¸í•˜ëŠ” ë‹¨ìˆœ ë°˜ë³µ êµ¬ì¡°
- (6) Greedy	âŒ í•„ìš” ì—†ìŒ	ì„ íƒ/ìµœì í™” ê°œë… ì—†ìŒ
- (7) DP	âŒ ë¶ˆí•„ìš”	ì´ì „ ê²°ê³¼ ì €ì¥Â·í™œìš© êµ¬ì¡° ì•„ë‹˜
- (8) Graph / DFS-BFS	âŒ ë¬´ê´€	ì—°ê²° êµ¬ì¡° ì—†ìŒ
- (9) Binary Search	âŒ í•„ìš” ì—†ìŒ	ì •ë ¬ëœ ë¦¬ìŠ¤íŠ¸ íƒìƒ‰ êµ¬ì¡° ì•„ë‹˜

[3] íë¦„ ì„¤ê³„
- (1) ì „ì²´ ì¢Œí‘œë¥¼ ì €ì¥í•  ë°°ì—´ ìƒì„± (í˜¹ì€ dict)
- (2) ê° ì„ ë¶„ì˜ êµ¬ê°„ [start, end) ë²”ìœ„ë§Œí¼ ë°˜ë³µí•˜ë©° í•´ë‹¹ ì¢Œí‘œì— 1ì”© ì¦ê°€
- (3) ê²¹ì¹¨ì´ 2 ì´ìƒì¸ êµ¬ê°„ì„ ëª¨ë‘ ë”í•¨
"""


def solution(lines):
    # ì¢Œí‘œì˜ ë²”ìœ„ëŠ” -100 ~ 100ì´ë¯€ë¡œ ì´ 201ê°œì˜ êµ¬ê°„ì„ ê´€ë¦¬í•´ì•¼ í•¨
    # count[i]ëŠ” ì¢Œí‘œ (i - 100) ìœ„ì¹˜ê°€ ì„ ë¶„ì— ì˜í•´ ëª‡ ë²ˆ í¬í•¨ë˜ì—ˆëŠ”ì§€ë¥¼ ì˜ë¯¸
    count = [0] * 201  # ì¸ë±ìŠ¤ 0 ~ 200 â†’ ì¢Œí‘œ -100 ~ 100

    # ê° ì„ ë¶„ì˜ ë²”ìœ„ë¥¼ ìˆœíšŒí•˜ë©° í•´ë‹¹ ì¢Œí‘œì— í¬í•¨ëœ íšŸìˆ˜ë¥¼ ê¸°ë¡
    # ë¦¬ìŠ¤íŠ¸ ì–¸íŒ©í‚¹: ë°˜ë“œì‹œ ê¸¸ì´ê°€ 2ì¸ ë¦¬ìŠ¤íŠ¸ë‚˜ íŠœí”Œì´ì–´ì•¼ í•©ë‹ˆë‹¤.
    for start, end in lines:
        # ë¬¸ì œ ì¡°ê±´ì— ë”°ë¼ endëŠ” í¬í•¨í•˜ì§€ ì•ŠìŒ â†’ [start, end)
        for i in range(start, end):
            print(start, end)
            # ì¢Œí‘œ iì— ì„ ë¶„ì´ í•˜ë‚˜ ì§€ë‚¬ìŒì„ í‘œì‹œ
            # iê°€ ìŒìˆ˜ì¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ +100 ë³´ì •ì„ í†µí•´ 0 ì´ìƒ ì¸ë±ìŠ¤ë¡œ ë§ì¶¤
            count[i + 100] += 1

    # ê²¹ì³ì§„ êµ¬ê°„ì˜ ê¸¸ì´ ê³„ì‚°: ì„ ë¶„ì´ 2ë²ˆ ì´ìƒ ì§€ë‚˜ê°„ êµ¬ê°„ë§Œ ì…ˆ
    overlap_length = sum(1 for x in count if x >= 2)
    print(overlap_length)

    # ìµœì¢… ê²°ê³¼ ë°˜í™˜
    return overlap_length

lines = [[0, 2], [-3, -1], [-2, 1]]
solution(lines)

# def solution(lines):
#     # ì¢Œí‘œë³„ë¡œ ê²¹ì¹œ íšŸìˆ˜ë¥¼ ê¸°ë¡í•  ë”•ì…”ë„ˆë¦¬
#     point_map = {}
#
#     print("ğŸ“Œ ê° ì„ ë¶„ì˜ ì¢Œí‘œ ì²˜ë¦¬ í˜„í™©:")
#     for start, end in lines:
#         print(f"â¤ ì„ ë¶„: [{start}, {end})")
#         for i in range(start, end):
#             # í•´ë‹¹ ì¢Œí‘œì˜ ì¹´ìš´íŠ¸ë¥¼ 1 ì¦ê°€ (ê¸°ì¡´ê°’ì´ ì—†ìœ¼ë©´ 0)
#             point_map[i] = point_map.get(i, 0) + 1
#             print(f"  - ì¢Œí‘œ {i}: {point_map[i]}íšŒ")
#
#     print("\nğŸ“Œ ìµœì¢… ì¢Œí‘œë³„ ê²¹ì¹œ íšŸìˆ˜:")
#     for key in sorted(point_map):
#         print(f"ì¢Œí‘œ {key}: {point_map[key]}íšŒ")
#
#     # 2ê°œ ì´ìƒ ì„ ë¶„ì´ ê²¹ì¹œ ì¢Œí‘œë§Œ ì¹´ìš´íŠ¸
#     overlap_coords = [key for key, val in point_map.items() if val >= 2]
#     print("\nâœ… 2ê°œ ì´ìƒ ê²¹ì¹œ ì¢Œí‘œ ëª©ë¡:", overlap_coords)
#     print("ğŸ¯ ê²¹ì¹œ êµ¬ê°„ì˜ ì´ ê¸¸ì´:", len(overlap_coords))
#
#     return len(overlap_coords)