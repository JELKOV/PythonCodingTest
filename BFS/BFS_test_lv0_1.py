"""
# 정수를 나선형으로 배치하기
[1] 문제 설명

(1) 목표
→ 1부터 n²까지의 숫자를 시계 방향 나선형으로 n x n 2차원 배열에 채워라.

(2) 룰
→ 오른쪽 → 아래 → 왼쪽 → 위의 순서대로 반복하며 숫자를 채움.
이미 값이 있거나 범위를 벗어나면 방향을 바꿈.

(3) 입력 값
→ 정수 n (1 ≤ n ≤ 30)

(4) 출력 값
→ 나선형으로 숫자가 채워진 n x n 2차원 리스트

(5) 예외 상황
→ 없음 (n의 범위가 명확히 주어짐)

[2] 자료구조 / 알고리즘의 선택

(1) Hash	❌ 필요 없음
(2) Queue/Direction	🔶 유사	방향 전환 시 방향 배열(dx, dy) 사용
(3) Heap	❌ 우선순위 없음
(4) Sorting	❌ 정렬 없음
(5) Brute Force	✅ 사용	모든 칸을 하나씩 채움 (반복문 O(n²))
(6) Greedy	❌ 최선 선택 아님
(7) DP	❌ 저장/재활용 없음
(8) Graph/DFS/BFS	❌ 연결 탐색 아님
(9) Binary Search	❌ 탐색 없음

[3] 흐름 설계
n x n 크기의 2차원 배열 생성 (0으로 초기화)
방향 배열 준비 (→ ↓ ← ↑) → dx, dy
초기 위치 (x, y) = (0, 0), 방향 인덱스 = 0
1부터 n²까지 하나씩 채우기 시작
다음 칸이 범위를 벗어나거나 이미 값이 채워져 있다면 → 방향 전환
(x, y)를 다음 칸으로 갱신
모든 숫자 채울 때까지 반복
최종 배열 반환
"""

def solution(n):
    # n x n 크기의 2차원 배열을 0으로 초기화
    answer = [[0] * n for _ in range(n)]

    # 시계방향으로 이동하기 위한 방향 벡터 (→ ↓ ← ↑ 순서)
    dx = [0, 1, 0, -1]  # 행 변화: x축 이동
    dy = [1, 0, -1, 0]  # 열 변화: y축 이동

    # 시작 좌표 (맨 왼쪽 위)
    x, y = 0, 0
    # 현재 방향 인덱스 (0: 오른쪽, 1: 아래, 2: 왼쪽, 3: 위)
    move = 0

    # 1부터 n^2까지 숫자를 나선형으로 채우기
    for i in range(1, n * n + 1):
        # 현재 좌표에 i 값을 채움
        answer[x][y] = i

        # 다음 좌표 계산 (현재 방향 기준으로 한 칸 이동)
        nx = x + dx[move]
        ny = y + dy[move]

        # 디버깅용 출력: 현재 좌표와 다음 좌표
        print("x,y", x, y)
        print("nx,ny", nx, ny)

        # 다음 좌표가 배열 범위를 벗어났거나, 이미 채워진 경우 → 방향 전환 필요
        if nx < 0 or nx >= n or ny < 0 or ny >= n or answer[nx][ny] != 0:
            # 방향 인덱스를 0~3 사이에서 순환
            move = (move + 1) % 4
            # 방향을 바꿨으니, 새로운 방향으로 다시 좌표 재계산
            nx = x + dx[move]
            ny = y + dy[move]

        # 좌표 이동 (다음 루프에서 이 위치에 i+1이 들어갈 예정)
        x, y = nx, ny

    # 완성된 나선형 배열 반환
    return answer

# 예시 출력 (n=4일 때)
print(solution(4))
