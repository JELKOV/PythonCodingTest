"""
# 문제명: 앞을 볼 수 있는 소의 수 세기 (스택 활용) LV_1

[1] 문제 설명

    (1) 목표
    - N마리의 소가 일렬로 서 있으며, 각 소의 키가 주어진다.
    - 한 소는 자신보다 앞에 있으면서 자기보다 키가 큰 소들만 볼 수 있다.
    - 각 소마다 앞에 보이는 소들의 수를 합산하여 총합을 출력한다.

    (2) 규칙
    - 소는 앞에 있는 소만 본다 (뒤는 안 봄)
    - 자신보다 키가 작거나 같은 소는 시야를 막지 않으며 제거됨
    - 스택에 남아 있는 소들만 현재 소가 볼 수 있는 대상

    (3) 입력 값
    - N (int): 소의 수 (1 ≤ N ≤ 100,000)
    - heights (List[int]): N마리 소들의 키

    (4) 출력 값
    - 모든 소가 볼 수 있는 소의 수의 총합 (int)

    (5) 예외 상황
    - 입력은 유효한 범위로 주어진다고 가정 (0 이상의 정수 키)

[2] 자료구조

    - List[int]: heights → 소들의 키 입력값 저장
    - Stack (List): stack → 현재 기준에서 볼 수 있는 앞의 소들을 저장
    - Integer: count → 총 볼 수 있는 소의 수 누적

[3] 알고리즘

    - Stack:
        - 스택에 자기보다 작은/같은 소를 제거하여 앞에 볼 수 있는 대상만 유지
        - 각 소가 볼 수 있는 소 수 = 현재 스택 길이

    - Brute Force보다 효율적:
        - O(N) 시간복잡도로 해결 가능 (각 원소 최대 1번 push, 1번 pop)

    - Basic Simulation + 상태 갱신:
        - 조건문 + 반복문으로 시야 확보 여부를 판단

[4] 흐름 설계

    (1) 입력 처리:
        - N (소 수), heights (소들의 키 리스트) 입력

    (2) 초기 상태:
        - count = 0 (총 볼 수 있는 소 수)
        - stack = [] (현재 시야 안의 소들 저장)

    (3) 반복 처리:
        - 각 소의 키 currentHeight 순차 접근
        - stack에서 현재 소보다 키가 작거나 같은 소는 제거
        - count += len(stack) (현재 볼 수 있는 소 수)
        - stack.append(currentHeight) → 현재 소는 뒤 소의 시야 대상

    (4) 출력 반환:
        - count 출력
"""

# 소의 수를 입력받음
N = int(input("소의 수를 입력하세요: "))

# 소들의 키를 저장할 배열
heights = list(map(int, input("소의 키를 입력하세요: ").split()))

count = 0  # 볼 수 있는 소의 수를 누적할 변수
stack = []  # 소들의 키를 저장할 스택 역할의 리스트

# 각 소를 순차적으로 처리
for currentHeight in heights:
    # 스택의 최상단에 있는 소가 현재 소보다 작거나 같은 경우 제거
    while stack and stack[-1] <= currentHeight:
        stack.pop()  # 스택에서 마지막 소 제거
    
    # 스택에 남아 있는 소의 수만큼 현재 소가 볼 수 있음
    count += len(stack)
    
    # 현재 소의 키를 스택에 추가
    stack.append(currentHeight)

# 결과 출력 (모든 소들이 볼 수 있는 소의 수)
print(count)
 